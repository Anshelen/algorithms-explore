"""
Задача о сетевых пакетах.

У компьютера, обрабатывающего пакеты, имеется сетевой буфер размера size. До
начала обработки пакеты хранятся в буфере. Если буфер полностью заполнен в
момент поступления пакета (есть size пакетов, поступивших ранее, которые до сих
пор не обработаны), этот пакет отбрасывается и уже не будет обработан. Если
несколько пакетов поступает в одно и то же время, они все будут сперва сохранены
в буфер (несколько последних из них могут быть отброшены, если буфер
заполнится). Компьютер обрабатывает пакеты в порядке их поступления. Он начинает
обрабатывать следующий пакет из буфера сразу после того, как обработает текущий
пакет. Компьютер может простаивать, если все пакеты уже обработаны и в буфере
нет пакетов. Пакет освобождает место в буфере сразу же, как компьютер
заканчивает его обработку.

Пакет задается двумя числами, обозначающими время поступления и длительность
обработки пакета. Пакеты на входе отсортированы по времени поступления.

Для каждого из пакетов надо найти время, когда процессор начал его обрабатывать,
или −1, если пакет был отброшен.

Пример:
Буффер емкостью 1. Пакеты (0 1) и (0 2).
Выход: [0, -1].
Первый пакет поступил в момент времени 0, второй пакет поступил также в момент
времени 0, но был отброшен, поскольку буфер в этот момент полностью заполнен
(первым пакетом).
"""

from typing import Tuple, Sequence, List

from structures.queue import Queue

# Сетевой пакет. Задается двумя числами (a, b), где a - время поступления
# пакета, b - длительность обработки пакета
NetPackage = Tuple[int, int]


def get_start_times(size: int, packages: Sequence[NetPackage]) -> List[int]:
    """
    Для каждого из пакетов находит время, когда процессор начал его
    обрабатывать, или −1, если пакет был отброшен.

    :param size: размер буффера
    :param packages: список пакетов в порядке их прибывания в виде кортежей
        из времени прибытия пакета и длительности его обработки
    :return: список из временных меток, когда процессор начал обрабатывать пакет
        или -1, если пакет был отброшен
    """
    res = [-1] * len(packages)
    if size <= 0 or not packages:
        return res

    # Буффер. Храним в нем порядковые номера пакетов в исходном списке
    queue = Queue()
    queue.push(0)

    i, time = 1, packages[0][0]
    while True:
        if queue:
            processing_pack_i = queue.peek()
            res[processing_pack_i] = time
            time += packages[processing_pack_i][1]
            while i < len(packages) and packages[i][0] < time:
                if len(queue) < size:
                    queue.push(i)
                i += 1
            queue.pop()
        elif i < len(packages):
            queue.push(i)
            time = packages[i][0]
            i += 1
        else:
            break
    return res


if __name__ == '__main__':
    assert get_start_times(0, [(1, 1)]) == [-1]
    assert get_start_times(1, []) == []
    assert get_start_times(1, [(1, 1)]) == [1]
    assert get_start_times(1, [(0, 1), (1, 1)]) == [0, 1]
    assert get_start_times(1, [(0, 1), (0, 1)]) == [0, -1]
    assert get_start_times(1, [(0, 1), (1, 1), (5, 5)]) == [0, 1, 5]
    assert get_start_times(1, [(0, 5), (0, 1), (1, 1)]) == [0, -1, -1]
    assert get_start_times(2, [(0, 5), (0, 1), (1, 1)]) == [0, 5, -1]
    assert get_start_times(3, [(0, 5), (0, 1), (1, 1)]) == [0, 5, 6]
    assert get_start_times(4, ((0, 5), (0, 1), (1, 1))) == [0, 5, 6]
